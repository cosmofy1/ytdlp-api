import time
import asyncio
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import yt_dlp

app = FastAPI()

# ========== –ö–ï–®–ò–†–û–í–ê–ù–ò–ï ==========
audio_url_cache = {}
CACHE_TTL = 18000  # 5 —á–∞—Å–æ–≤ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö

def get_cached_url(video_id: str) -> str | None:
    """–ü–æ–ª—É—á–∏—Ç—å URL –∏–∑ –∫–µ—à–∞, –µ—Å–ª–∏ –Ω–µ –∏—Å—Ç—ë–∫"""
    if video_id in audio_url_cache:
        entry = audio_url_cache[video_id]
        if entry['expires'] > time.time():
            print(f"‚úÖ [CACHE HIT] {video_id}")
            return entry['url']
        else:
            print(f"‚è∞ [CACHE EXPIRED] {video_id}")
            del audio_url_cache[video_id]
    return None

def set_cached_url(video_id: str, url: str):
    """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å URL –≤ –∫–µ—à"""
    audio_url_cache[video_id] = {
        'url': url,
        'expires': time.time() + CACHE_TTL
    }
    print(f"üíæ [CACHE SET] {video_id} -> expires in 5h")

# ========== YT-DLP ==========
def extract_audio_url(video_id: str) -> str:
    """–ü–æ–ª—É—á–∏—Ç—å direct audio URL —á–µ—Ä–µ–∑ yt-dlp"""
    ydl_opts = {
        'format': 'bestaudio/best',
        'quiet': True,
        'no_warnings': True,
        'extract_flat': False,
    }
    
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        info = ydl.extract_info(
            f"https://www.youtube.com/watch?v={video_id}", 
            download=False
        )
        return info['url']

# ========== ENDPOINTS ==========
@app.get("/audio/{video_id}")
async def get_audio_url(video_id: str):
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç direct audio URL (—Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º)"""
    
    # 1. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–µ—à
    cached = get_cached_url(video_id)
    if cached:
        return {"audioUrl": cached, "source": "cache", "cached": True}
    
    # 2. –ï—Å–ª–∏ –Ω–µ—Ç –≤ –∫–µ—à–µ ‚Äî yt-dlp
    print(f"üîç [YT-DLP] Extracting {video_id}...")
    start = time.time()
    
    url = extract_audio_url(video_id)
    
    elapsed = time.time() - start
    print(f"‚úÖ [YT-DLP] Done in {elapsed:.1f}s")
    
    # 3. –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –∫–µ—à
    set_cached_url(video_id, url)
    
    return {"audioUrl": url, "source": "yt-dlp", "cached": False}


@app.get("/stream/{video_id}")
async def stream_audio(video_id: str):
    """–°—Ç—Ä–∏–º–∏–Ω–≥ –∞—É–¥–∏–æ (—Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º URL)"""
    
    # 1. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–µ—à ‚Äî –µ—Å–ª–∏ –µ—Å—Ç—å, —Å—Ç—Ä–∏–º–∏–º –°–†–ê–ó–£
    cached = get_cached_url(video_id)
    if cached:
        print(f"üöÄ [STREAM] Fast start from cache: {video_id}")
        return await stream_from_url(cached)
    
    # 2. –ï—Å–ª–∏ –Ω–µ—Ç –≤ –∫–µ—à–µ ‚Äî –ø–æ–ª—É—á–∏—Ç—å –∏ –∑–∞–∫–µ—à–∏—Ä–æ–≤–∞—Ç—å
    print(f"‚è≥ [STREAM] Cache miss, extracting: {video_id}")
    url = extract_audio_url(video_id)
    set_cached_url(video_id, url)
    
    return await stream_from_url(url)


async def stream_from_url(url: str):
    """–°—Ç—Ä–∏–º–∏–Ω–≥ –∏–∑ direct URL"""
    import httpx
    
    async def generate():
        async with httpx.AsyncClient() as client:
            async with client.stream("GET", url) as response:
                async for chunk in response.aiter_bytes(chunk_size=8192):
                    yield chunk
    
    return StreamingResponse(
        generate(),
        media_type="audio/mpeg",
        headers={
            "Accept-Ranges": "bytes",
            "Cache-Control": "no-cache",
        }
    )
